/**
**[How Does Authentication Work (In React & NextJS Apps)]
- We have our client(browser), and the user visiting our page through that browser,
and our server serving that page, NOTE: The server also is connected to a database,
where for example, all our registered users are stored.

*? Story:
- Now let's assume a user did already create an account, And now that same user visits
our page and wants to login
*! How does that work?
- Well, the user enters some data into a login form, When that happens, we send the http
request to the server, our request which contains the user data, then on the server,
we can validate that input, We can reach out to our database, TODO: and see if we find
an account for that email address, TODO: And if the entered password matches the password
we find in the database.

- And then we sent back a response, which basically says, yes, your credentials were correct,
You are authenticated, or which declines the authentication request, And then once we sent back
that yes or no response, NOTE: the client can there after also reach protected routes and send
requests to other endpoints, on our server to our URLs that might require authentication,
Like for example that profile page We're only able to reach it once we are authenticated, And we
also only can change the password if we are, So if that request is sent to some backend API, that the
old password should be replaced with a new one, that kind of request should only be allowed and fulfilled
if the user is authenticated, So that request which we send needs some extra data attached to the request,
which in the end tells the backend that this user is authenticated, NOTE: Because anyone could be sending
requests to our API.

- and hence the request needs to carry some extra permission, which then should be verified on the server,
And that permission part is important, Because a simple yes or no sent back by the server to the client
would not be enough, Because we can of course always send a request to some API endpoint that requires
authentication, and say, "Hey, I'm authenticated", We can't just believe that as the author of the API,
TODO: we need some proof that a user is authenticated, And therefore authentication involves this exchange
of credentials for permission,TODO: To be precise we can't just save and use a simple "yes", because
of fake yes, could be sent, We can't just tell our server that we are authenticated and then request
protected data, or perform protected operations.

- Complete: And therefore, we need some proof, Some proof that can't be faked, And for this, we've got
two main mechanisms, these are two common approaches for solving this problem of un-fake-able permissions.

*?1- authentication tokens:
- The idea here is that the server does not store any identifiers, Instead, the server creates and signs
tokens, Which in the end are just a random strings you could say, Random strings which can be unpacked
to data packages, so we take various pieces of data and sign them together more on that in a second,
TODO: And then such a token is sent back to the client, The client can then save that token, and again
attach it to outgoing requests to tell the server that access should be granted, NOTE: So the server
will be able to verify if a token was created by it or not.

** About Secure The Tokens:
- if I just come up with some random token string and I send this to a server to get access
to some protected resource, access would be denied, because the server would not be able to
verify my random string, Because it wouldn't be a validly signed token generated by that server.

- Now, even though the server does not store that token in a database or anywhere else, the server
knows how it's signed that token.

*?2- server-side session:
works such that we store some unique identifier on a server, So we generate some session ID, which is unique,
And we store that on the server, for example, in a database, And we sent that same identifier to the client,
that sent us the credentials, Then on the client, we can store that ID that identifier, And then we can use
that stored identifier to attach it to requests which we there after are send to protected resources on the
server, And then the server is always able to extract that identifier from the incoming requests, check if
it's stored that identifier in the database, and if it did grant access, and if it does not deny access,
TODO: Now then only clients which have does identifier are able to send requests.

*!Now you might say, okay, but can this identify be stolen?
- Well, while it's in transit it shouldn't be stolen because we should be using SSL for encrypting
to connection anyways, And when it is stored on the client side it is stored in a cookie typically,
and that cookie can be configured such that it's not accessible through JavaScript to prevent cross-site
scripting attacks, And that it is only readable from the server when it is attached to outgoing requests.
*/
//!==============================================================================
/**
**[SPAs Work With Tokens Instead Of Sessions]
- Now when we build a single-page application which we in the end still kind of do with Next.js,
then we typically work with tokens instead of sessions, And there are reasons for that:

1- pages are served directly and populated, Of course, when working with Next.js, NOTE: you can build
pages which use get server-side props and therefore there will be a request handled by the server every
time that page is being served, But you will also have many pages which are pre-generated, And once
the user is on your website many pages won't be fetched from the backend at all, but instead will
be loaded and generated dynamically with front-end JavaScript because you still have a single-page
application at least for many pages that make up your website after you initially loaded your first page,
then still JavaScript takes over, React takes over and handles your website, so You don't send a request
for every page you visit, NOTE: because you're not using get server-side props on every page.

- So to server, doesn't see every request which you send, and therefore you load pages without
the server being able to directly find out if you are authenticated or not.

2- backend APIs which be used for a single-page applications are typically stateless, They don't
care about the individual connected clients, They don't keep track of all the connected clients,
Instead, the idea is that, that API can work pretty much on its own, And it just is able to hand
out permissions to clients who authenticated, so that they can then later request access to protect
the resources, NOTE: The API itself does not store any extra information about any connected clients,
And since this is how we build single-page applications the server is not involved in every request,
and every action that's happening on our page because we handled that with front-end JavaScript, and
we have that stateless API connected to the SPA.

- And because of all of that, we could say that we have kind of a detached front-end and back-end
combination, They do talk to each other sometimes, but not for every action that's going on on the page,
TODO: And because that's the case, servers don't save information about authenticated clients, And instead
clients should get that standalone permission which allows them to prove that they are authenticated,
NOTE: And that's why we use these tokens, and here we use a concept called JSON Web Tokens(JWT),
that is simply the most common form of authentication token, And it's simply describes the way
the token is generated, NOTE: though we don't need to care about that too much because we'll use
a third-party library for generating and signing that token anyways.
*/
//!==============================================================================
/**
**[Understanding JWT (JSON Web Tokens) And How it work]
- JSON Web Tokens is generated with three main blocks":
*?1- We got some issuer data:
- Some data which is automatically added into a token by the server when that token is generated,
That's some metadata which we typically don't set up ourselves as a developer, but which is pre-configured
by the third party packages we use for generating tokens.

*?2- custom data
We can then still also add custom data to our token, for example some information about the user.

*?3- we also set up a secret key.
- We set up that key on the server, The client never gets to see that key, And that's important
because if you have that key you can create valid tokens, which are accepted by the server, Hence
only the server knows that key, Then we generate a token with some third-party package by combining
all these pieces together, by creating a random string that incorporates all that data, and
is signed by that key And that is that JSON Web Token(a long string).

NOTE: The important thing here is that signing does not mean encryption, The JSON Web Token
is not encrypted, You can unpack it and read the data inside of it without knowing that key,
That key only proves that a given server created that token, But you can read the content of
the token without knowing that key, So you can't read that key, even if you unpack the token,

- Now is that token which then is stored by the client, By the browser, And which then is attached
to requests, to protected resources on the server, So two protected API routes, And for example,
if you wanna change our password, we don't just send the old and the new password, but we also include
that token in the outgoing request, And that token then is validated by the server, which basically checks,
Okay, If I would use my signing key which only I know, would I be able to generate this token?,
And if the answer is, ye. The server knows that it's valid, If the answer is no. It's invalid
and access is denied.

*? Final:
- So that's why we can't just generate a token without knowing the key. We can generate a token,
but it would be an invalid one, And that's why this is a secure mechanism.
*/
//!==============================================================================
/**
**[server-side session & secure the identifier]
- And even if it would be accessible through JavaScript you should be protecting against cross-site
scripting attacks anyways, And if you can rule out cross-site scripting attacks your authentication
permission stored in some client-side storage is pretty secure, Because only you, the owner of this
computer, and the user of this browser are able to view it, So you could only hack yourself, and some
random dude wouldn't be able to just send a fake request to the server because whilst you could come
up with a random identifier the server would not know that identifier.
*/
//!==============================================================================
/**
**[Using The "next-auth" Library]
- next-auth supports a broad variety of authentication for writers, So you can't just go with
your own email and password combination, You can also easily add Sign In with Google or Facebook
or Apple or whatever you want with NextAuth.

- NextAuth package has both server-side and client-side capabilities, We'll be able to use
it on some API routes to verify if a user is logged in and we'll be able to use it in our
components to do the same, Because of course the answer to the question whether a user is logged in
and authenticated is not just needed on protected resources on the server-side, so in our API routes,
but also in our client-side components, There we also might want to show a different user interface,
based on whether a user is authenticated or not, And NextAuth will allow us to do both, server-side
and client-side validation, It will also help us with generating those Auth Tokens(JWT).
*/
//!==============================================================================
/**
**[Secure Users Password & bcryptjs]
- We should not store the plain password the database, because if our database ever gets
compromised by some employee or a third-party intruder, then all our user credentials
would be usable just like this, Hence for security reasons, it is a best practice and
strongly recommended, that you don't store plain passwords in the database.

- TODO: but that you instead encrypt them such that they can't be decrypted, and we will still
be able to verify them later, no worries, but we want to make sure that we store passwords
in encrypted form.

- TODO: and to encrypt passwords, we can install another third-party package and that's
bcryptjs, That's a package which helps us to encrypt passwords or encrypt any kind of data,
then import the hash function from "bcryptjs", TODO: Then I want to export an async function
called hashPassword and take the original plain text password as an input(parameter), and
then call hash(password) and pass to it password as a first argument, and the second argument
then should be a number of salting rounds, which in the end will influence how strong that
password is, and here a value of 12 is considered to be safe.

- TODO: and hash will then also return a promise which eventually gets gives us that encrypted password,
So we can await this to have our hashed password.
*/
//!==============================================================================
/**
**[Improving Signup With Unique Email Addresses]
- because we can create the same user with the same email address, multiple times,
And that's typically not what we want to do, Therefore, to avoid that we do that,
TODO: in our signup handler function, we should check if a user for a given email
already exists, So once we connected here to the database, before we hash the password
and store the user.

TODO: I want to check if a user already exists, collection.findOne() method, findOne
allows us to find one document, and we pass a object to findOne, where we describe how
to search for that document, and the keys are the keys we have in our documents, Now
we should await findOne(), because it returns a promise.
*/
//!==============================================================================
/**
**[Adding the "Credentials Auth Provider" & User Login Logic]
- that's now the part of NextAuth package, It helps us with authenticating users
and it helps us with finding out whether a user has that permission, by managing
that token creation and storage, both parts behind the scenes.

- Now, to use NextAuth, we start by adding another API route, because logging a user in,
signing a user in, that requires a request to be sent to a certain API route, where we then
look into the database, and find out whether we have that user in the database and whether
the password is correct.

- And therefore, I'll create another file, but this file now needs a special name, So a dynamic
API route and it's a dynamic catch all API route[...], which catches all unknown routes

- and in this file, we use that NextAuth package in that dynamic catch all API route, TODO: And
we need this catch all route because the next auth package behind the scenes will expose multiple
routes, for user login and for user logout, for example, And in order to set up its own routes,
and handle its own routes, we need to have a catch all route.

- TODO: We need to import NextAuth from "next-auth", and we export NextAuth as a default
and execute it, So NextAuth here is a function, and when we execute it, it returns a new
function, a handler function, It needs to because this is still an API route, NOTE: and that
exported handler function is created by calling NextAuth, And then we can pass a configuration
object to it, That's the object which allows us to configure NextAuth's behavior, then we
add a Providers array, then add our Providers inside it.

*? authorize method:
It's a async method so it returns a promise, which Next.js will call for us when it receives
a incoming login request, and as an argument we get the credentials that were submitted, And
that is the object with the data we submitted, we now have to bring our own authorization logic
, check if the credentials are valid, and tell the user if that's not the case.
*/
//!==============================================================================
/**
**[Sending a "SignIn" Request From The Frontend]
- import {signIn} from "next-auth/client", That's a function which we can call in our component,
to send a signIn request, And the request will be sent automatically, and we can pass some data
// as an argument, The first argument describes the provider with which we wanna signIn, Because
we could have multiple providers in the same application, in our case, It's the credentials provider,
Then we pass a second argument, That is a configuration object,, where we can configure how the signIn
process should work, And specifically here, we can add a redirect field and set it to false, because
when we have an error(authentication failed), that by default next JS would redirect us to another page,
to an error page.

- Now when setting redirect to false, signIn we'll actually return up promise, which eventually yields
us our result, NOTE: The promise will always resolve, It will not be rejected  Even if we have an error
in our back-end authentication code, But if we had an error there, result would be an object that
contains information about the error, TODO: If we have no error during authentication, result is still
an object, but without the error information.

- And now besides passing redirect key, we also wanna pass our credential data to the back-end.
*/
//!==============================================================================
/**
**[Managing Active Session (On The Frontend)]
- when we update auth state, but whenever we reload that state would be lost, because
we start a brand new single page application, All the state, which was only stored in memory
from the last visit would be lost, And that's not what we want, NOTE: because that's exactly why
we have this token concept, We can store that token in some more permanent storage than just our
memory, And we can then also use that token to send requests to potentially protected APIs, like
the change password API.

- TODO: Next.js makes that pretty easy for us, It is worth noting that after we logged in
successfully, Next.js added a cookie, and these are cookies which are generated and managed
by Next.js, and this session token is this Jason web token in the end, That was set automatically
by Next.js when we logged in successfully, And it will also use that token automatically for us,
when we try to change what we see on the screen, or when we try to send requests to protected
resources.

- if you wanna find out if the user using our page at the moment is authenticated or not,
Next.js gives us a convenient way of doing that, Let's say in the main navigation component,
here I wanna show profile link only if the user is authenticated, all we have to do for that
is we have to import {useSession} from "next-auth/react", useSession is a react hook, it return
an object have two key first is an object describing the act of session, and the second element
is status which tells us wherever Next.js is currently still figuring out whether we are logged in or not.
*/
//!==============================================================================
/**
**[Adding User Logout]
- now to logout we can, use function provided by next-auth/react, And that is the signOut function,
And that returns a promise, which tells us when it's done, But here I don't even care
about that TODO: because since I'm using useSession the component will be updated automatically
anyways, as soon as the active session changes, And it will change when we sign out, NextAuth
will then clear that cookie and clear the information of the active user who is logged in.

- and we inspect our cookies, we also see that one very important cookie is missing,
and this session token cookie, That's missing now because NextAuth cleared that when we sent
this signOut request.
*/
//!==============================================================================
/**
**[Adding Client-Side Page Guards (Route Protection)]
- implementing that is never straightforward with nextAuth, All we have to do in the end
is go to the pages which we wanna protect or restrict in some way, Like the profile page,
And then also use some nextAuth functionality there, Either directly on that page, or in
a component of that page, TODO: I want to redirect the way if we're not authenticated.
*/
//!==============================================================================
/**
**[Adding Server-Side Page Guards (And When To Use Which Approach)]
- that brief moment of loading, which flashes on the screen when we enter profile when not
authenticated that is maybe something we want to get rid of, Now, we can't really get rid of
it with just client side code, because if we visit this page and we then use client side
JavaScript code to determine whether we are authenticated or not, then we'll always need to
wait that fraction of a second to find out if we are.

- TODO: But we must not forget that Next.js blends server side and client side code, so we can
use server side code to determine whether the user, who sent the request, is authenticated or not
and return different page content, and possibly a redirect if the user is not authenticated,
For this, we need to go to the profile page, We could, add the getStaticProps function, But
that's the wrong function, why? TODO: Because you must not forget that getStaticProps runs during
build time, it can also run thereafter with revalidate set to a certain duration, but it mainly
runs during build time, It does absolutely not run for every incoming request.

- we should use getServerSideProps, And the good thing about getSession it not limited to using
it on client side code only, you can also use getSession on the server side, then we call getSession
and actually pass in an object where we set a req key to the incoming request, which we get out
of the context object, And then, getSession will automatically look into that request and extract
the data it needs => the session token cookie, and see if that's valid, and if the user is authenticated.
and if that cookie even exists to begin with, that will all happen behind the scenes.

- TODO: the page component will only be rendered if we are authenticated
*/
//!==============================================================================
/**
**[nextAuth getSession() function]
- the difference is that with useSession we immediately get this session and status,
and then both session and status could change if session data was fetched, If we have no
session because we're logged out session will never change though(NOTE: old version v3),

- getSession works differently, getSessions, sends a new request and gets to latest session
data.
*/
//!==============================================================================
/**
**[nextAuth getServerSession() function]
- NOTE: Read About getServerSession() in next Auth Documentation
*/
//!==============================================================================
/**
**[Using the "next-auth" Session Provider Component]
- At the moment, we're using this session functionality in a couple of different components,
Now, one problem we have with that is that if we are authenticated and if I reload while on this
profile page, then we figure out whether the user is authenticated or not in that getServerSideProps
function of that page, and then after the page was loaded, the useSession hook which we use
in our components, We'll technically also, again, run some logic to find out whether we
have a session or not, TODO: And we see this here in the Network tab, If I reload, you see there
is a request being sent to /api/auth/session, That request is actually sent by that useSession hook,
And it's sent to check Whether that session cookie which had found is valid, because we can't validate
that with client site JavaScript for security reasons, NOTE: Hence that cookie needs to be sent to an
end point which then determines whether it is valid or not, So that's why this request is being sent.

- There is nothing wrong with this request, but since we already checked our session in getServerSideProps,
we already know that we are authenticated or not, So this is actually a redundant request which is being
sent by useSession Hook.

TODO: And we can avoid it, by using a SessionProvider component offered by nextAuth in our _app.JS file,
This is a wrapper which we can wrap around all our other components, and then Provider wants a session
prop, and here we simply set any session data, which we might already have from our getServerSideProps,
And that then allows nextAuth to skip the extra session check performed by useSession Hook, If we
already have the session in our getServeSideProps.

NOTE: Now, if we load another component, where session is not set in page props, session undefined
and useSession We'll still do its thing and check it manually, TODO: But in cases where we already
know that there is a session, we can save some performance and a avoid some redundant HTTP requests.
*/
//!==============================================================================
/**
**[Analyzing Further Authentication Requirements]
- when we say session here, we are talking about json web token(JWT), Which is managed automatically
by NextAuth, Which is stored by NextAuth in our browser cookie, which holds this token is created there.

- TODO: And Next Auth determines whether we have an active session, so if this user is logged in,
by checking that cookie and that token, That is what happens when we call getSession function,
or when we use the useSession hook.

NOTE: Now one crucial feature is missing, one of the main reasons for adding authentication,
Because having this client site protection here is nice, protecting certain pages and making sure
we can't reach certain pages, But what really matters is what we as a user can do, Which API
routes we can hit, for example, if you're building an online shop, you might only want to allow
logged in users, to create and delete and manage products, And in the interface which your website
has for managing those products, you would be sending requests behind the scenes, to certain API endpoints,
Where those requests then trigger certain operations, Like the creation of a product, or the deletion of
a product, And of course you want to make sure that, those requests only trigger those operations, if they
come from authenticated users.

TODO: So that if you have API routes in your project, API routes that do certain operations, that are
only allowed for authenticated users, that in those API routes you also "verify", whether that request
is coming from an authenticated user or not, From the command line, with tools like Postman, So there
are ways of sending requests to your APIs, that don't require your website, NOTE: And therefore protecting
the pages on those websites, is one thing but we also need protection in those API routes, Where we validate
incoming requests, and double check that this request is coming from an authenticated source.
*/
//!==============================================================================
/**
**[Protecting API Routes]
- change user password in profile page This clearly is an operation that should be restricted,
Not every user should be allowed to change a password, It only makes sense for authenticated users,

- TODO: we want to extract the old and new password which the user entered, We want
to verify that the request is coming from an authenticated user, and deny for reaction
if it's not:
*?1- We want to get the email address of that authenticated user then.
*?2- and then we want to look into the database, see if we find that user there.
*?3- see if the old password that was entered matches the current password in the database.

TODO: and if that's the case, we want to replace that old password with the new password.
*/
